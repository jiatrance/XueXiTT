1
00:00:00,000 --> 00:00:03,360
 [音乐播放] 

2
00:00:03,360 --> 00:00:05,814


3
00:00:05,815 --> 00:00:06,940
 JOSH GORDON：嘿，大家好。 

4
00:00:06,940 --> 00:00:08,129
欢迎回来。 

5
00:00:08,129 --> 00:00:10,170
功能是您表达知识的方式

6
00:00:10,170 --> 00:00:12,320
关于分类器的世界， 

7
00:00:12,320 --> 00:00:14,130
今天我会引导你学习技巧

8
00:00:14,130 --> 00:00:16,740
您可以使用它来表示您的功能和实用程序

9
00:00:16,740 --> 00:00:19,169
 TensorFlow提供帮助。 

10
00:00:19,170 --> 00:00:22,320
您使用美国人口普查中的数据集作为示例， 

11
00:00:22,320 --> 00:00:24,480
目标是预测某人的收入是否是

12
00:00:24,480 --> 00:00:27,960
超过50,000美元，基于他们年龄的属性

13
00:00:27,960 --> 00:00:29,760
和职业。 

14
00:00:29,760 --> 00:00:32,310
数据集存储为CSV文件， 

15
00:00:32,310 --> 00:00:35,580
之前我们已经看到了如何直接使用列值

16
00:00:35,580 --> 00:00:37,230
作为功​​能。 

17
00:00:37,230 --> 00:00:38,879
但今天我们将使用特征工程

18
00:00:38,880 --> 00:00:42,360
将它们转化为更有用的表示。 

19
00:00:42,360 --> 00:00:45,210
随着我们的进展，我将可视化这些转换的作用

20
00:00:45,210 --> 00:00:48,180
使用名为Facets的工具，您可以找到它的链接

21
00:00:48,180 --> 00:00:49,800
在描述中。 

22
00:00:49,800 --> 00:00:52,739
您还可以找到训练TensorFlow估算器的完整代码

23
00:00:52,740 --> 00:00:54,420
在这个数据集上。 

24
00:00:54,420 --> 00:00:55,410
好的，让我们开始吧。 

25
00:00:55,410 --> 00:00:57,959


26
00:00:57,960 --> 00:01:00,230
让我们从像age这样的数字属性开始， 

27
00:01:00,230 --> 00:01:03,230
并考虑如何使用它来预测收入。 

28
00:01:03,230 --> 00:01:05,840
现在，如果你想一想年龄与收入的关系， 

29
00:01:05,840 --> 00:01:08,300
我们的第一个直觉是，随着年龄的增长， 

30
00:01:08,300 --> 00:01:10,399
收入通常也是如此。 

31
00:01:10,400 --> 00:01:12,320
并且最简单的方式来表示这一点

32
00:01:12,320 --> 00:01:14,509
只是采取原始数值

33
00:01:14,510 --> 00:01:16,197
并将其用作功能。 

34
00:01:16,197 --> 00:01:17,780
在这里，我们正在构建一个功能列表

35
00:01:17,780 --> 00:01:20,360
我们用来训练模型，以及每个模型

36
00:01:20,360 --> 00:01:22,340
存储为要素列。 

37
00:01:22,340 --> 00:01:25,340
其中包含有关CSV文件中列的数据

38
00:01:25,340 --> 00:01:27,160
以及如何表现它。 

39
00:01:27,160 --> 00:01:30,619
在这里，我们将编写一个仅使用age的原始值的功能， 

40
00:01:30,620 --> 00:01:34,100
此字符串对应于CSV文件中的列。 

41
00:01:34,100 --> 00:01:36,442
现在这种方法会出现什么问题？ 

42
00:01:36,442 --> 00:01:38,149
好吧，如果我们更仔细地思考年龄， 

43
00:01:38,150 --> 00:01:41,630
我们意识到它与收入没有线性关系。 

44
00:01:41,630 --> 00:01:43,979
曲线可能看起来像这样。 

45
00:01:43,980 --> 00:01:47,000
对于孩子来说这是平的，然后在工作年龄期间增加， 

46
00:01:47,000 --> 00:01:49,220
退休时减少。 

47
00:01:49,220 --> 00:01:50,810
例如，线性分类器

48
00:01:50,810 --> 00:01:53,480
无法捕捉到这种关系。 

49
00:01:53,480 --> 00:01:55,940
那是因为它为每个特征学习了一个权重。 

50
00:01:55,940 --> 00:01:58,820


51
00:01:58,820 --> 00:02:01,550
为了使分类器更容易​​，我们可以做一件事

52
00:02:01,550 --> 00:02:03,200
是这个功能。 

53
00:02:03,200 --> 00:02:05,510
并且bucketing转换数字功能

54
00:02:05,510 --> 00:02:07,700
分为几个分类

55
00:02:07,700 --> 00:02:11,150
在它所涉及的范围，以及这些新功能中的每一个

56
00:02:11,150 --> 00:02:14,940
表明一个人的年龄是否属于该范围。 

57
00:02:14,940 --> 00:02:17,480
现在，线性模型可以捕捉到这种关系

58
00:02:17,480 --> 00:02:20,079
通过为每个桶学习不同的权重。 

59
00:02:20,080 --> 00:02:22,430
让我们看一下Facets的外观。 

60
00:02:22,430 --> 00:02:23,870
方便的是，有一个现场演示

61
00:02:23,870 --> 00:02:27,350
在预先加载我们的人口普查数据的情况下在浏览器中运行， 

62
00:02:27,350 --> 00:02:30,200
并且可视化来自CSV的每个人

63
00:02:30,200 --> 00:02:32,720
作为收入的彩色圆点。 

64
00:02:32,720 --> 00:02:36,550
如果单击某个点，则可以看到有关该人的统计信息。 

65
00:02:36,550 --> 00:02:38,690
现在让我们按年龄划分，你可以

66
00:02:38,690 --> 00:02:41,900
调整桶的数量，使其或多或少粒状。 

67
00:02:41,900 --> 00:02:44,240
你如何选择水桶的数量取决于你， 

68
00:02:44,240 --> 00:02:46,760
理想情况下，你想要运用你对问题的了解

69
00:02:46,760 --> 00:02:48,560
做得好。 

70
00:02:48,560 --> 00:02:50,840
在TensorFlow中，我们可以创建一个bucketized功能

71
00:02:50,840 --> 00:02:53,720
通过包装CSV中的数字列。 

72
00:02:53,720 --> 00:02:55,340
在这里我们指定数字

73
00:02:55,340 --> 00:02:58,220
以及我们想要创建的桶的范围。 

74
00:02:58,220 --> 00:03:00,440
完成后，我们可以添加bucketized功能

75
00:03:00,440 --> 00:03:02,030
到用于训练我们模型的列表。 

76
00:03:02,030 --> 00:03:05,200


77
00:03:05,200 --> 00:03:07,799
现在让我们看看如何表示一个分类特征， 

78
00:03:07,800 --> 00:03:10,740
我将以教育专栏为例。 

79
00:03:10,740 --> 00:03:12,600
因为只有几个值， 

80
00:03:12,600 --> 00:03:16,207
表示这个的最好方法就是使用原始值。 

81
00:03:16,207 --> 00:03:17,790
在这里，我们将创建一个功能列

82
00:03:17,790 --> 00:03:21,420
这表示教育可以是此列表中的单个值。 

83
00:03:21,420 --> 00:03:24,359
当然，您也可以从磁盘上的文件中读取值

84
00:03:24,360 --> 00:03:27,030
而不是在代码中写出来。 

85
00:03:27,030 --> 00:03:28,950
现在使用原始值是正确的

86
00:03:28,950 --> 00:03:32,164
当只有少数可能性时要做。 

87
00:03:32,164 --> 00:03:34,079
我们将介绍有成千上万的情况

88
00:03:34,080 --> 00:03:35,716
一瞬间的可能性。 

89
00:03:35,716 --> 00:03:37,590
首先，我们来看看特征交叉。 

90
00:03:37,590 --> 00:03:40,372


91
00:03:40,372 --> 00:03:42,580
特征交叉是一种创建新功能的方法

92
00:03:42,580 --> 00:03:44,770
是现有的组合， 

93
00:03:44,770 --> 00:03:47,780
这些对线性分类器特别有用， 

94
00:03:47,780 --> 00:03:51,040
它无法模拟特征之间的交互。 

95
00:03:51,040 --> 00:03:53,410
这是Facets中的样子。 

96
00:03:53,410 --> 00:03:55,150
我会从以前拿走我们的年龄桶

97
00:03:55,150 --> 00:03:57,400
并通过教育交叉他们。 

98
00:03:57,400 --> 00:04:00,070
在引擎盖下，你可以想到一个真假的特征

99
00:04:00,070 --> 00:04:02,079
为每个告诉的桶创建

100
00:04:02,080 --> 00:04:04,060
分类器是否个人失败

101
00:04:04,060 --> 00:04:05,890
进入那个范围。 

102
00:04:05,890 --> 00:04:07,690
现在这些桶可以提供信息， 

103
00:04:07,690 --> 00:04:10,660
在这里我们看到一些团体可能有高收入， 

104
00:04:10,660 --> 00:04:12,220
和其他人低。 

105
00:04:12,220 --> 00:04:15,850
在代码中，使用特征交叉以与以前相同的方式工作。 

106
00:04:15,850 --> 00:04:17,860
我们将通过教育跨越我们的年龄段

107
00:04:17,860 --> 00:04:20,300
并将其添加到要使用的功能列表中。 

108
00:04:20,300 --> 00:04:23,345
特征交叉可以快速生成许多可能性， 

109
00:04:23,345 --> 00:04:24,970
这就是他们经常被代表的原因

110
00:04:24,970 --> 00:04:26,140
用哈希引擎盖下。 

111
00:04:26,140 --> 00:04:29,044


112
00:04:29,044 --> 00:04:32,440
散列特征列是有效表示的一种方法

113
00:04:32,440 --> 00:04:35,380
具有大词汇量的分类特征。 

114
00:04:35,380 --> 00:04:37,000
更重要的是，您可以使用这些

115
00:04:37,000 --> 00:04:38,440
作为一种使您的数据更容易的方法

116
00:04:38,440 --> 00:04:40,750
因为他们让你免于拥有

117
00:04:40,750 --> 00:04:43,300
提供词汇表。 

118
00:04:43,300 --> 00:04:45,760
在这个例子中，我们将代表职业列

119
00:04:45,760 --> 00:04:48,190
从我们的CSV文件中使用哈希

120
00:04:48,190 --> 00:04:50,570
有1,000个可能的值。 

121
00:04:50,570 --> 00:04:53,380
请注意，我们不必提供词汇表， 

122
00:04:53,380 --> 00:04:55,570
为了避免冲突，我设置了哈希大小

123
00:04:55,570 --> 00:04:58,840
所以它大于词汇表中的项目数。 

124
00:04:58,840 --> 00:05:01,060
以下是它如何在引擎盖下工作。 

125
00:05:01,060 --> 00:05:03,130
通常，表示分类特征

126
00:05:03,130 --> 00:05:04,840
作为一个热门编码。 

127
00:05:04,840 --> 00:05:07,239
这意味着每个可能的值都有一位

128
00:05:07,240 --> 00:05:08,620
在词汇表中。 

129
00:05:08,620 --> 00:05:11,110
我们可以创建一个查找，因为我们知道词汇

130
00:05:11,110 --> 00:05:12,790
提前列出。 

131
00:05:12,790 --> 00:05:14,500
现在，如果我们不知道词汇，我们

132
00:05:14,500 --> 00:05:17,680
可以使用哈希函数自动计算位。 

133
00:05:17,680 --> 00:05:19,810
缺点是可能会发生碰撞， 

134
00:05:19,810 --> 00:05:23,020
意味着不同的项目映射到相同的值。 

135
00:05:23,020 --> 00:05:25,630
哈希也可用于限制内存使用

136
00:05:25,630 --> 00:05:28,540
以增加训练数据的噪音为代价。 

137
00:05:28,540 --> 00:05:30,247
如果你有一个很大的词汇量，它

138
00:05:30,247 --> 00:05:32,080
可以使用内存密集型作为输入

139
00:05:32,080 --> 00:05:33,325
到神经网络。 

140
00:05:33,325 --> 00:05:35,380
散列列可用于限制

141
00:05:35,380 --> 00:05:37,540
最大可能性， 

142
00:05:37,540 --> 00:05:39,160
但我更喜欢它们只是一种工具

143
00:05:39,160 --> 00:05:40,450
为您节省编程时间。 

144
00:05:40,450 --> 00:05:43,370


145
00:05:43,370 --> 00:05:45,290
最后，我想提一下嵌入， 

146
00:05:45,290 --> 00:05:47,780
这些可能不如其他技术直观， 

147
00:05:47,780 --> 00:05:50,113
但它们是处理分类数据的有效方式

148
00:05:50,113 --> 00:05:51,950
在深度学习环境中。 

149
00:05:51,950 --> 00:05:54,620
您可以将嵌入视为代表的向量

150
00:05:54,620 --> 00:05:56,270
一个词的意思。 

151
00:05:56,270 --> 00:05:58,490
我们可以可视化单词嵌入的数据集

152
00:05:58,490 --> 00:06:00,830
使用TensorFlow嵌入投影仪， 

153
00:06:00,830 --> 00:06:04,070
您可以在说明中找到在线演示。 

154
00:06:04,070 --> 00:06:07,340
在这里，我们正在查看10,000个单词的数据集，每个单词都是如此

155
00:06:07,340 --> 00:06:09,830
由具有多个维度的向量表示， 

156
00:06:09,830 --> 00:06:12,440
投影到3D，所以我们可以看到它们。 

157
00:06:12,440 --> 00:06:14,612
您可以在右侧的框中搜索单词。 

158
00:06:14,612 --> 00:06:16,070
如果你试验一下，你会

159
00:06:16,070 --> 00:06:18,650
发现类似的单词往往很接近。 

160
00:06:18,650 --> 00:06:21,827
例如，此群集中的所有单词都是城市。 

161
00:06:21,827 --> 00:06:23,660
什么是嵌入式的整洁是他们的

162
00:06:23,660 --> 00:06:26,900
在培训DNN的过程中自动学习。 

163
00:06:26,900 --> 00:06:28,700
为了实现这一目标，您需要做的就是

164
00:06:28,700 --> 00:06:30,587
写一个嵌入列。 

165
00:06:30,587 --> 00:06:32,420
在这里，我们将为教育创建一个嵌入

166
00:06:32,420 --> 00:06:34,852
有10个尺寸。 

167
00:06:34,852 --> 00:06:37,310
如果您有分类列，现在嵌入很有用

168
00:06:37,310 --> 00:06:39,140
你想要的词汇量很大

169
00:06:39,140 --> 00:06:42,020
压缩表示，以便分类器学习

170
00:06:42,020 --> 00:06:44,419
一般概念而不是记忆

171
00:06:44,420 --> 00:06:46,850
具体词汇的含义。 

172
00:06:46,850 --> 00:06:48,620
例如，想象一下人口普查数据

173
00:06:48,620 --> 00:06:50,840
有一个名为职称的专栏。 

174
00:06:50,840 --> 00:06:52,710
有成千上万的不同工作， 

175
00:06:52,710 --> 00:06:55,310
嵌入可以用来帮助你的分类器学习

176
00:06:55,310 --> 00:06:57,980
那些像程序员和软件工程师的话

177
00:06:57,980 --> 00:06:59,150
通常意味着同样的事情。 

178
00:06:59,150 --> 00:07:01,929


179
00:07:01,930 --> 00:07:04,090
好的，希望这是一个有用的介绍， 

180
00:07:04,090 --> 00:07:06,210
并考虑如何表示您的功能

181
00:07:06,210 --> 00:07:07,960
是最重要的贡献之一

182
00:07:07,960 --> 00:07:10,397
你可以进行机器学习实验。 

183
00:07:10,397 --> 00:07:11,980
功能列很棒，因为它们

184
00:07:11,980 --> 00:07:14,021
让你尝试不同的表示

185
00:07:14,021 --> 00:07:16,260
在代码中并使嵌入等高级功能

186
00:07:16,260 --> 00:07:17,590
无障碍。 

187
00:07:17,590 --> 00:07:19,090
下一步，我建议你

188
00:07:19,090 --> 00:07:21,940
尝试描述中的代码，看看是否可以修改它

189
00:07:21,940 --> 00:07:23,950
对于你关心的问题。 

190
00:07:23,950 --> 00:07:26,770
感谢收看大家，下次我会见到你。 

191
00:07:26,770 --> 00:07:30,120
 [音乐播放] 

192
00:07:30,120 --> 00:07:37,408


