1
00:00:00,000 --> 00:00:06,011


2
00:00:06,011 --> 00:00:07,510
 JOSH GORDON：我们训练的最后一集

3
00:00:07,510 --> 00:00:10,500
在使用TensorFlow for Poets的图像分类器中， 

4
00:00:10,500 --> 00:00:13,552
而这一次，我们将使用TF.Learn编写一个。 

5
00:00:13,552 --> 00:00:15,010
我们今天要解决的问题是

6
00:00:15,010 --> 00:00:18,400
从MNIST数据集中分类手写数字， 

7
00:00:18,400 --> 00:00:21,000
并经常为这些写一个简单的分类器

8
00:00:21,000 --> 00:00:23,780
被认为是计算机视觉的Hello World。 

9
00:00:23,780 --> 00:00:26,940
现在MNIST是一个多类别的分类问题。 

10
00:00:26,940 --> 00:00:28,620
给出一个数字的图像，我们的工作

11
00:00:28,620 --> 00:00:30,880
将预测它是哪一个。 

12
00:00:30,880 --> 00:00:32,900
我为这一集写了一个IPython笔记本， 

13
00:00:32,900 --> 00:00:35,110
你可以在描述中找到它的链接。 

14
00:00:35,110 --> 00:00:37,630
为了使您更容易配置您的环境， 

15
00:00:37,630 --> 00:00:39,630
我将从安装的快速截屏开始

16
00:00:39,630 --> 00:00:41,576
使用Docker的TensorFlow。 

17
00:00:41,576 --> 00:00:43,450
首先，这是我们将要介绍的内容的概述。 

18
00:00:43,450 --> 00:00:45,158
我将向您展示如何下载数据集

19
00:00:45,158 --> 00:00:46,530
并可视化图像。 

20
00:00:46,530 --> 00:00:49,050
接下来，我们将训练分类器，评估它， 

21
00:00:49,050 --> 00:00:51,910
并用它来预测新的图像。 

22
00:00:51,911 --> 00:00:54,160
然后我们将可视化分类器学习的权重

23
00:00:54,160 --> 00:00:56,940
获得直觉，了解它如何在引擎盖下工作。 

24
00:00:56,940 --> 00:00:59,397
让我们从安装TensorFlow开始。 

25
00:00:59,397 --> 00:01:00,980
您可以找到安装说明

26
00:01:00,980 --> 00:01:03,089
对于从“入门”页面链接的Docker 

27
00:01:03,090 --> 00:01:06,020
在TensorFlow.org上，我将开始这个截屏视频

28
00:01:06,020 --> 00:01:08,479
假设您刚刚完成下载和安装

29
00:01:08,480 --> 00:01:12,450
 Docker本身但还没有开始安装TensorFlow。 

30
00:01:12,450 --> 00:01:15,300
从彻底安装Docker开始，首先要做的事情

31
00:01:15,300 --> 00:01:17,539
打开Docker Quickstart终端。 

32
00:01:17,540 --> 00:01:20,040
当出现这种情况时，您只会看到一个IP地址

33
00:01:20,040 --> 00:01:21,280
在鲸鱼下面。 

34
00:01:21,280 --> 00:01:22,060
将其复制下来。 

35
00:01:22,060 --> 00:01:23,509
我们稍后会需要它。 

36
00:01:23,509 --> 00:01:25,050
接下来，我们将启动一个Docker容器

37
00:01:25,050 --> 00:01:26,810
使用TensorFlow图像。 

38
00:01:26,810 --> 00:01:28,670
该映像托管在Docker hub上， 

39
00:01:28,670 --> 00:01:30,810
并且在描述中有一个链接。 

40
00:01:30,810 --> 00:01:33,580
该图像包含TensorFlow及其所有依赖项

41
00:01:33,580 --> 00:01:35,880
正确配置，这是命令

42
00:01:35,880 --> 00:01:38,360
我们将用于下载和启动图像。 

43
00:01:38,360 --> 00:01:41,574
但首先，让我们选择我们想要的版本。 

44
00:01:41,574 --> 00:01:43,240
版本在这个页面上，我们会

45
00:01:43,240 --> 00:01:44,850
使用最新版本。 

46
00:01:44,850 --> 00:01:47,419
现在我们可以将命令复制粘贴到终端中

47
00:01:47,420 --> 00:01:49,670
并添加一个带有版本号的冒号。 

48
00:01:49,670 --> 00:01:51,700
如果这是您第一次运行图像， 

49
00:01:51,700 --> 00:01:53,260
它会自动下载。 

50
00:01:53,260 --> 00:01:56,257
在随后的运行中，它将在本地缓存。 

51
00:01:56,257 --> 00:01:58,340
图像自动启动，默认情况下启动

52
00:01:58,340 --> 00:01:59,500
运行笔记本服务器。 

53
00:01:59,500 --> 00:02:01,880
剩下的就是打开一个浏览器

54
00:02:01,880 --> 00:02:06,310
并将其指向我们之前在端口8888上记下的IP。 

55
00:02:06,310 --> 00:02:08,060
现在我们有一台IPython笔记本

56
00:02:08,060 --> 00:02:10,430
我们可以在我们的浏览器中进行实验

57
00:02:10,430 --> 00:02:11,549
由容器。 

58
00:02:11,549 --> 00:02:14,090
您可以在说明中找到此剧集的笔记本

59
00:02:14,090 --> 00:02:16,590
并通过UI上传。 

60
00:02:16,590 --> 00:02:17,090
好。 

61
00:02:17,090 --> 00:02:18,600
现在进入代码。 

62
00:02:18,600 --> 00:02:20,180
以下是我们将使用的进口产品。 

63
00:02:20,180 --> 00:02:22,670
我将使用matplotlib来显示图像，当然， 

64
00:02:22,670 --> 00:02:25,429
我们将使用TF.Learn来训练分类器。 

65
00:02:25,430 --> 00:02:27,810
所有这些都随图像一起安装。 

66
00:02:27,810 --> 00:02:30,200
接下来，我们将下载MNIST数据集， 

67
00:02:30,200 --> 00:02:32,709
我们有一个漂亮的衬垫。 

68
00:02:32,710 --> 00:02:35,080
数据集包含数千个带标签的图像

69
00:02:35,080 --> 00:02:36,450
手写的数字。 

70
00:02:36,450 --> 00:02:39,459
它被预先划分为火车，即55,000， 

71
00:02:39,460 --> 00:02:41,620
和测试，这是10,000。 

72
00:02:41,620 --> 00:02:44,520
让我们想象一下这些中的一些来感受一下。 

73
00:02:44,520 --> 00:02:47,380
此代码显示图像及其标签， 

74
00:02:47,380 --> 00:02:49,280
你可能会注意到我正在重塑图像， 

75
00:02:49,280 --> 00:02:52,050
我会稍微解释一下原因。 

76
00:02:52,050 --> 00:02:54,480
测试集中的第一张图片是七， 

77
00:02:54,480 --> 00:02:57,760
你可以看到示例索引以及标签。 

78
00:02:57,760 --> 00:02:59,660
这是第二张图片。 

79
00:02:59,660 --> 00:03:01,180
现在这两个都清楚地画了， 

80
00:03:01,180 --> 00:03:03,096
但是有各种不同的笔迹

81
00:03:03,096 --> 00:03:04,300
此数据集中的样本。 

82
00:03:04,300 --> 00:03:06,990
这是一个难以识别的图像。 

83
00:03:06,990 --> 00:03:09,340
这些图像分辨率很低，只有28 

84
00:03:09,340 --> 00:03:11,750
灰度等级为28像素。 

85
00:03:11,750 --> 00:03:14,250
另请注意，它们已正确分段。 

86
00:03:14,250 --> 00:03:17,760
这意味着每个图像只包含一个数字。 

87
00:03:17,760 --> 00:03:20,049
现在让我们来谈谈我们将要使用的功能。 

88
00:03:20,050 --> 00:03:21,660
当我们处理图像时，我们

89
00:03:21,660 --> 00:03:23,770
使用原始像素作为功能。 

90
00:03:23,770 --> 00:03:25,560
那是因为提取有用的功能

91
00:03:25,560 --> 00:03:28,360
从图像，如纹理和形状，很难。 

92
00:03:28,360 --> 00:03:31,770
现在28 x 28的图像有784像素， 

93
00:03:31,770 --> 00:03:34,117
所以我们有784个功能。 

94
00:03:34,117 --> 00:03:36,200
在这里，我们使用扁平表示

95
00:03:36,200 --> 00:03:37,560
图像。 

96
00:03:37,560 --> 00:03:40,250
平整图像意味着将其从2D阵列转换

97
00:03:40,250 --> 00:03:43,566
通过拆除行并将它们排成一行来形成一维数组。 

98
00:03:43,566 --> 00:03:45,190
这就是为什么我们不得不重塑这个阵列

99
00:03:45,190 --> 00:03:47,260
先显示它。 

100
00:03:47,260 --> 00:03:49,200
现在我们可以初始化分类器， 

101
00:03:49,200 --> 00:03:51,589
在这里，我们将使用线性分类器。 

102
00:03:51,590 --> 00:03:53,360
我们将提供两个参数。 

103
00:03:53,360 --> 00:03:55,730
第一个表示我们有多少课程， 

104
00:03:55,730 --> 00:03:58,660
并且有10个，每种类型的数字一个。 

105
00:03:58,660 --> 00:04:00,230
第二个通知分类器

106
00:04:00,230 --> 00:04:02,269
关于我们将使用的功能。 

107
00:04:02,270 --> 00:04:04,730
现在我将绘制一个线性分类器的快速图表

108
00:04:04,730 --> 00:04:07,595
为您提供有关它如何工作的高级预览。 

109
00:04:07,595 --> 00:04:08,970
你可以想到分类器

110
00:04:08,970 --> 00:04:11,280
加上图像的证据

111
00:04:11,280 --> 00:04:13,020
每种类型的数字。 

112
00:04:13,020 --> 00:04:15,910
输入节点位于顶部，由Xes表示， 

113
00:04:15,910 --> 00:04:19,219
输出节点位于Ys表示的底部。 

114
00:04:19,220 --> 00:04:22,750
我们为图像中的每个要素或像素都有一个输入节点

115
00:04:22,750 --> 00:04:24,340
每个数字一个输出节点

116
00:04:24,340 --> 00:04:26,099
图像可以代表。 

117
00:04:26,100 --> 00:04:29,777
在这里，我们有784个输入和10个输出。 

118
00:04:29,777 --> 00:04:31,610
我刚刚画了一些，所以一切

119
00:04:31,610 --> 00:04:32,740
适合屏幕。 

120
00:04:32,740 --> 00:04:35,240
现在输入和输出完全连接， 

121
00:04:35,240 --> 00:04:37,560
并且这些边缘中的每一个都具有重量。 

122
00:04:37,560 --> 00:04:40,350
当我们对图像进行分类时，您可以考虑每个像素

123
00:04:40,350 --> 00:04:41,830
正如旅行一样。 

124
00:04:41,830 --> 00:04:44,130
首先，它流入其输入节点， 

125
00:04:44,130 --> 00:04:46,650
然后，它沿着边缘移动。 

126
00:04:46,650 --> 00:04:49,590
一路上，它乘以边缘的重量， 

127
00:04:49,590 --> 00:04:51,650
并且输出节点收集证据

128
00:04:51,650 --> 00:04:55,750
我们分类的图像代表每种类型的数字。 

129
00:04:55,750 --> 00:04:58,430
我们收集的证据越多，就八个输出而言， 

130
00:04:58,430 --> 00:05:01,060
图像越有可能是八。 

131
00:05:01,060 --> 00:05:03,160
并计算我们有多少证据， 

132
00:05:03,160 --> 00:05:06,250
我们将像素强度的值相乘

133
00:05:06,250 --> 00:05:07,430
按重量。 

134
00:05:07,430 --> 00:05:09,970
然后我们可以预测图像属于输出

135
00:05:09,970 --> 00:05:12,170
证据最充分的节点。 

136
00:05:12,170 --> 00:05:13,870
重要的部分是重量， 

137
00:05:13,870 --> 00:05:15,420
通过正确设置，我们可以

138
00:05:15,420 --> 00:05:17,160
获得准确的分类。 

139
00:05:17,160 --> 00:05:20,130
我们从随机权重开始，然后逐渐调整它们

140
00:05:20,130 --> 00:05:21,510
为了更好的价值观

141
00:05:21,510 --> 00:05:24,030
这发生在fit方法中。 

142
00:05:24,030 --> 00:05:26,820
一旦我们有一个训练有素的模型，我们就可以对其进

143
00:05:26,820 --> 00:05:28,290
我们看到使用evaluate方法

144
00:05:28,290 --> 00:05:31,730
它正确地分类了大约90％的测试集。 

145
00:05:31,730 --> 00:05:34,860
我们还可以对单个图像进行预测。 

146
00:05:34,860 --> 00:05:37,400
这是一个正确分类的，这里是

147
00:05:37,400 --> 00:05:39,676
一个是错的。 

148
00:05:39,676 --> 00:05:41,800
现在我想告诉你如何可视化权重

149
00:05:41,800 --> 00:05:43,520
分类器学习。 

150
00:05:43,520 --> 00:05:45,599
这里，正权重以红色绘制， 

151
00:05:45,600 --> 00:05:48,650
负权重用蓝色绘制。 

152
00:05:48,650 --> 00:05:50,440
那么这些重量告诉我们什么呢？ 

153
00:05:50,440 --> 00:05:53,800
好吧，要了解这一点，我将展示四张图片。 

154
00:05:53,800 --> 00:05:55,480
它们都略有不同， 

155
00:05:55,480 --> 00:05:57,600
但看看中间的像素。 

156
00:05:57,600 --> 00:06:00,390
请注意，它已填入每个图像。 

157
00:06:00,390 --> 00:06:02,289
当填充该像素时，它就是

158
00:06:02,290 --> 00:06:04,640
证据表明我们正在看的图像是一个， 

159
00:06:04,640 --> 00:06:07,409
所以我们期待在那条边上的高速公路。 

160
00:06:07,410 --> 00:06:09,270
现在让我们来看看四个零。 

161
00:06:09,270 --> 00:06:11,450
请注意，中间像素为空。 

162
00:06:11,450 --> 00:06:13,680
虽然有很多方法可以绘制零， 

163
00:06:13,680 --> 00:06:15,330
如果填充了中间像素， 

164
00:06:15,330 --> 00:06:17,659
这是反对图像为零的证据， 

165
00:06:17,660 --> 00:06:19,972
所以我们期待边缘的负重。 

166
00:06:19,972 --> 00:06:21,680
看着重量的图像， 

167
00:06:21,680 --> 00:06:23,940
我们几乎可以看到绘制的数字的轮廓

168
00:06:23,940 --> 00:06:25,935
每个班级都是红色的。 

169
00:06:25,935 --> 00:06:28,060
我们能够想象这些，因为我们开始了

170
00:06:28,060 --> 00:06:31,870
有784像素，我们学会了10个权重，一个

171
00:06:31,870 --> 00:06:33,350
对于每种类型的数字。 

172
00:06:33,350 --> 00:06:36,200
然后我们将权重重塑为2D数组。 

173
00:06:36,200 --> 00:06:36,700
好。 

174
00:06:36,700 --> 00:06:37,489
这就是现在。 

175
00:06:37,489 --> 00:06:39,530
当然，还有更多要了解的内容， 

176
00:06:39,530 --> 00:06:41,614
我把我最喜欢的链接放在说明中。 

177
00:06:41,615 --> 00:06:43,990
下次来，我们将尝试深度学习， 

178
00:06:43,990 --> 00:06:46,860
我将更详细地介绍我们今天在这里介绍的内容。 

179
00:06:46,860 --> 00:06:49,760
非常感谢您的观看，我会再见到您。 

180
00:06:49,760 --> 00:06:53,110
 [音乐播放] 

181
00:06:53,110 --> 00:07:00,698


