1
00:00:00,000 --> 00:00:00,500


2
00:00:00,500 --> 00:00:05,900
好的，大家好，欢迎来到第三台机器学习和第二回归教程视频。 

3
00:00:06,300 --> 00:00:15,020
在我们离开的地方，我问的是调整后的关闭列是特征还是标签。 

4
00:00:15,020 --> 00:00:20,160
答案实际上是一个特征，可能没有上述特征。 

5
00:00:20,260 --> 00:00:28,000
嗯......如果我们还没有确定我们使用的是高负百分比，它可能是一个标签

6
00:00:28,600 --> 00:00:31,000
嗯...或百分比变化。 

7
00:00:31,000 --> 00:00:35,520
例如，如果，您可以使用adjust close作为标签， 

8
00:00:35,740 --> 00:00:41,160
比如说，在当天开始的时候，你试图预测当天的收盘价。 

9
00:00:41,440 --> 00:00:47,320
但在这种情况下，我们选择了给定的功能，你甚至都不知道这个值。 

10
00:00:47,320 --> 00:00:49,540
嗯，你不会知道高负值

11
00:00:49,540 --> 00:00:51,220
你不会知道百分比的变化

12
00:00:51,340 --> 00:00:53,180
直到收盘已经发生。 

13
00:00:53,380 --> 00:00:57,540
所以，如果你训练了一个分类器来预测这个值， 

14
00:00:57,900 --> 00:01:01,340
嗯，这将是一个令人难以置信的偏见分类器。 

15
00:01:01,340 --> 00:01:05,000
所以，你必须开始考虑这些事情。 

16
00:01:05,000 --> 00:01:07,000
这在现实世界中甚至可能吗？ 

17
00:01:07,180 --> 00:01:09,100
因为你可以找到自己做事

18
00:01:09,100 --> 00:01:14,060
呃那时候看起来像个好主意，但实际上甚至不可能做到。 

19
00:01:14,360 --> 00:01:18,280
所以，在我们的例子中，调整后的关闭将是一个特征， 

20
00:01:18,280 --> 00:01:21,860
或不是，在我们将要做的事实上意义上的上述任何一个

21
00:01:21,860 --> 00:01:26,960
就像调整后的关闭的最后10个值一样，这是一个特征。 

22
00:01:26,960 --> 00:01:33,400
而且，这是我们实际上自己去挖掘和编写算法时最具代表性的

23
00:01:33,680 --> 00:01:37,200
 ，嗯，你可能会考虑最后10个值，并尝试预测未来的价值。 

24
00:01:37,380 --> 00:01:39,260
无论如何，稍后会更多。 

25
00:01:39,260 --> 00:01:46,000
所以最后一个，呃我们做的最后一个教程的功能，现在在本教程中我们将定义一个标签。 

26
00:01:46,000 --> 00:01:51,620
所以，既然我刚刚告诉你这不会是一个标签，那么实际上标签是什么？ 

27
00:01:51,620 --> 00:01:55,840
嗯，这将是在未来的某个时刻，价格。好的。 

28
00:01:55,840 --> 00:01:59,900
我们已经拥有的唯一价格列已经调整得很近了。 

29
00:01:59,900 --> 00:02:03,880
嗯，但我们想要做的事实上是将来调整得更近

30
00:02:03,880 --> 00:02:07,500
 ，也许是第二天，也许是接下来的5天，就像那样。 

31
00:02:07,680 --> 00:02:16,220
因此，我们需要引入一些新信息，主要是为了将这些信息提升到未来。 

32
00:02:16,220 --> 00:02:19,700
所以，让我们继续关闭它并开始研究它。 

33
00:02:20,360 --> 00:02:26,400
所以，首先，我们想...，我们要采取， 

34
00:02:26,420 --> 00:02:28,660
我们不再打印头了。 

35
00:02:28,860 --> 00:02:31,020
而且，首先， 

36
00:02:31,040 --> 00:02:35,680
我们要说forecast_column或col， 

37
00:02:35,680 --> 00:02:38,740
只会等于调整接近。 

38
00:02:38,760 --> 00:02:42,360
我会解释为什么我们会在一秒钟内做到这一点，但基本上它只是一个变量

39
00:02:42,380 --> 00:02:48,440
稍后，您可以将此变量更改为不同的预测列。 

40
00:02:48,900 --> 00:02:51,760
所以，你可能没有使用股票价格， 

41
00:02:51,760 --> 00:02:55,480
当你回归时，你可以使用其他东西，当然还有机器学习

42
00:02:55,480 --> 00:02:56,980
除了股票价格。 

43
00:02:57,240 --> 00:03:01,460
因此，在将来，如果你不是，你将会只是，你将能够使用非常相似的代码。 

44
00:03:01,720 --> 00:03:04,340
你显然会改变到目前为止的代码， 

45
00:03:04,620 --> 00:03:08,140
但您只需将预测列更改为您将来想要的任何内容。 

46
00:03:08,400 --> 00:03:12,340
我会告诉你为什么当我们到达代码时，为什么这会有用。 

47
00:03:12,400 --> 00:03:21,520
嗯，现在，我们要说的是万一没有，不是，呃缺少数据，所以df dot fill na。 

48
00:03:21,520 --> 00:03:26,680
所以填充na只是填充任何，如不可用或

49
00:03:26,740 --> 00:03:30,740
在熊猫术语中，在大多数情况下，它实际上是一个na，而不是一个数字。 

50
00:03:31,840 --> 00:03:35,560
所以现在我们要用特定的值填充na 

51
00:03:35,560 --> 00:03:40,700
我们要去做--99,999我们会说inplace equals true。 

52
00:03:40,840 --> 00:03:45,380
因此，通过机器学习，您无法使用na数据。 

53
00:03:45,560 --> 00:03:49,980
所以你实际上必须用某些东西替换na数据， 

54
00:03:50,240 --> 00:03:52,680
或者你可以摆脱整个专栏， 

55
00:03:52,680 --> 00:03:55,200
但你不想摆脱机器学习中的数据

56
00:03:55,200 --> 00:03:58,940
在现实世界中，你实际上会发现你错过了很多数据。 

57
00:03:59,020 --> 00:04:02,800
你可能缺少一列，但你有其他专栏， 

58
00:04:03,000 --> 00:04:05,620
如果你不需要，你不想牺牲数据。 

59
00:04:05,640 --> 00:04:10,860
因此，您可以执行此操作，并将其视为数据集中的异常值。 

60
00:04:10,980 --> 00:04:17,260
再次，这只是为什么要手动完成算法的另一个原因。 

61
00:04:17,540 --> 00:04:22,620
将帮助您更好地了解对算法会产生什么样的影响。 

62
00:04:22,700 --> 00:04:25,220
所以，你会感激我们经历它。 

63
00:04:25,320 --> 00:04:29,000
然后基本上你将通过每个算法学习为什么， 

64
00:04:29,000 --> 00:04:31,780
呃......做这样的事情会怎样？ 

65
00:04:31,920 --> 00:04:37,600
所以无论如何，这是选择，这是我认为最好的选择，而不是摆脱数据。 

66
00:04:37,900 --> 00:04:44,580
现在，我们要预测出来。这是一种回归算法，通常使用回归来预测。 

67
00:04:45,000 --> 00:04:48,160
你没有必要但通常这就是你在做什么。 

68
00:04:48,360 --> 00:05:03,200
所以我要将预测定义为等于数学点上限的int值，嗯，天花板将是df长度的1倍。 

69
00:05:03,200 --> 00:05:08,540
所以，首先，我们在那里做什么？而且我们还需要导入数学。但是，首先，我们在那里做什么？ 

70
00:05:08,540 --> 00:05:12,080
 math dot ceil将采取任何措施并达到最高限度。 

71
00:05:12,140 --> 00:05:18,780
那么让我们说数据帧的长度是一个会返回小数点的数字，那就像点2，对吧？ 

72
00:05:18,780 --> 00:05:26,060
让我们说那将会发生。数学点ceil会将其舍入到1.然后，数学点ceil将所有内容舍入到最接近的整数

73
00:05:26,060 --> 00:05:31,540
那么，嗯，然后我们把它变成一个整数值，嗯， 

74
00:05:31,540 --> 00:05:36,380
就这样，因为我认为math dot ceil返回一个浮点数，我们也不希望它成为浮点数。 

75
00:05:36,380 --> 00:05:41,840
但无论如何，呃，这将是天数，所以基本上我们要在这里做什么

76
00:05:41,920 --> 00:05:50,060
我们是否会尝试预测10％的数据帧，你会看到实际上当我们出去做这个时， 

77
00:05:50,080 --> 00:05:53,160
它不像你只得到1分10％， 

78
00:05:53,220 --> 00:05:56,460
你可以得到明天的价格和下一天的价格等等。 

79
00:05:56,460 --> 00:06:00,800
嗯，你刚刚使用10天前发布的数据来预测今天。好。 

80
00:06:00,800 --> 00:06:07,180
那么，嗯，随意改变它，对吧？也许你想要点01，对吗？ 

81
00:06:07,180 --> 00:06:09,440
也许你只想预测明天的价格或其他东西。 

82
00:06:09,520 --> 00:06:16,920
如果你愿意，你可以随意玩。我们基本上就像我们去做的那样。所以如果你想改变它，一定要改变它。 

83
00:06:16,920 --> 00:06:20,280
所以，在我们忘记之前，让我们继续前进并导入数学。 

84
00:06:20,280 --> 00:06:27,160
好的，现在，我们需要一个，实际的，所以我们有标签， 

85
00:06:27,520 --> 00:06:31,980
哦，对不起，我们有功能，对吗？这些是功能，或者这些是我们的功能

86
00:06:32,220 --> 00:06:36,040
现在我们需要这个标签，所以现在我们已经预测到我们可以创建该标签了。 

87
00:06:36,060 --> 00:06:40,920
所以我们要说df，然后是标签栏。 

88
00:06:40,920 --> 00:06:46,220
标签将等于df预测列， 

89
00:06:46,320 --> 00:06:50,700
这就是为什么我们使用预测列。那样，如果你以后决定改变一些东西

90
00:06:50,860 --> 00:06:55,680
你将能够只改变这个变量而不是所有的特征变量。 

91
00:06:55,860 --> 00:07:03,760
所以它将等于df预测列，然后我们将做一个点偏移减去预测。 

92
00:07:03,940 --> 00:07:07,420
这就是为什么我们需要它成为一个因为我们基本上改变列的原因。 

93
00:07:07,420 --> 00:07:10,440
所以，我们所做的就是消极地改变列。 

94
00:07:10,440 --> 00:07:15,120
所以它会去，基本上如果你在这里有一个专栏，它会被调高， 

95
00:07:15,120 --> 00:07:17,340
电子表格差不多。 

96
00:07:17,660 --> 00:07:30,900
这样，每行，每行的标签列将在未来10天内调整收盘价。 

97
00:07:31,180 --> 00:07:33,320
好的？这就是我们的标签， 

98
00:07:33,320 --> 00:07:47,040
因此，我们的特征是这些属性，在我们看来，可能导致10天内调整后的收盘价变化或10％。 

99
00:07:47,200 --> 00:07:53,380
所以实际上这将远远超过10天，因为我们甚至没有指定时间范围

100
00:07:53,380 --> 00:07:58,300
所以，我们稍后可以修改这个数字，它真的不那么重要。嗯，回归， 

101
00:07:58,300 --> 00:08:01,680
我保证，你不会因为这个算法而致富。 

102
00:08:01,680 --> 00:08:12,680
但它确实很好，你会发现这实际上并不是股票价格的坏模型。当你添加更多有用的功能时，它可以获得，它可以变得非常好。 

103
00:08:12,840 --> 00:08:20,140
但是，无论如何，嗯，现在我们有了标签栏，让我们继续打印df点头。 

104
00:08:20,140 --> 00:08:23,660
所以这只是打印出数据帧的前5行。 

105
00:08:23,840 --> 00:08:28,680
再说一次，如果我们正在做大熊猫的事情，你就像“发生了什么事？”。问和

106
00:08:28,680 --> 00:08:33,500
我可以指教你，因为我已经完成了基于我将要做的所有事情的教程。 

107
00:08:33,799 --> 00:08:40,939
嗯，好的，所以这些，我们的每一个列功能，然后我们终于有一个标签列，我们有点， 

108
00:08:40,940 --> 00:08:45,500
这是我们数据未来的时间。 

109
00:08:45,680 --> 00:08:49,080
那么，现在我们要做的就是...... 

110
00:08:49,140 --> 00:09:00,560
事实上，让我做一个df点，让我们做一个df点尾巴，让我们只做一个df点滴na然后到位等于真。 

111
00:09:00,740 --> 00:09:07,420
因为这些是一些可怕的高数字，10％。有趣。 

112
00:09:07,420 --> 00:09:10,620
所以我猜这个转变的价格变化很大。 

113
00:09:10,740 --> 00:09:14,900
所以让我们尝试一个较小的转变。嗯，很有趣， 

114
00:09:14,900 --> 00:09:16,900
这将是10％。 

115
00:09:16,900 --> 00:09:20,620
那更好一点。 

116
00:09:20,620 --> 00:09:23,440
也许，也许我们会使用那一点01。 

117
00:09:23,440 --> 00:09:26,200
让我们使用那个，因为其他的那么大。 

118
00:09:26,400 --> 00:09:29,420
所以，让我们回头看看，如果那个数字。 

119
00:09:29,420 --> 00:09:34,440
因此，如果您没有关注，我只是将预测价格与调整后的收盘价格进行比较。 

120
00:09:34,580 --> 00:09:39,220
当然，当股价开盘时，这实际上是一个显着的百分比变化，对， 

121
00:09:39,300 --> 00:09:41,180
从50到66， 

122
00:09:41,180 --> 00:09:45,820
但股票刚出来，当然谷歌做得很好。 

123
00:09:46,060 --> 00:09:53,240
所以，是的，但无论如何，是的，我想我现在会选择第01点。或者我们也会，每当我们去预测一些东西时，我们都会乱用机器人

124
00:09:53,240 --> 00:09:58,700
 Anywway。就是这个。所以我们做了功能，我们得到了我们的标签

125
00:09:58,700 --> 00:10:06,260
现在我们已经准备好对一些实际数据进行训练，测试，预测并实际运行该算法

126
00:10:06,260 --> 00:10:09,620
请继续关注。如果您有任何问题，意见，疑虑，那么到目前为止

127
00:10:09,620 --> 00:00:00,000
随意将它们留在下面。否则我总是感谢这些指示，直到下一次。 

